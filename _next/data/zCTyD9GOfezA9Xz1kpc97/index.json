{"pageProps":{"examples":{"default":"def main(private field a, field b) {\r\n    assert(a * a == b);\r\n    return;\r\n}","conditionals":"def main(field x) -> field {\r\n    field y = if x + 2 == 3 { 1 } else { 5 };\r\n    return y;\r\n}","for-loops":"def main() -> u32 {\r\n    u32 mut res = 0;\r\n    for u32 i in 0..4 {\r\n        for u32 j in i..5 {\r\n            res = res + i;\r\n        }\r\n    }\r\n    return res;\r\n}","functions":"def foo(field a, field b) -> field {\r\n    return a + b;\r\n}\r\n\r\ndef main() -> field {\r\n    return foo(1, 2);\r\n}","generics":"def sum<N>(field[N] a) -> field {\r\n    field mut res = 0;\r\n    for u32 i in 0..N {\r\n        res = res + a[i];\r\n    }\r\n    return res;\r\n}\r\n\r\ndef main(field[3] a) -> field {\r\n    return sum(a);\r\n}","merkleTree":"import \"hashes/sha256/512bit\" as hash;\r\nimport \"hashes/utils/256bitsDirectionHelper\" as multiplex;\r\n\r\nconst u32 DEPTH = 3;\r\n\r\ndef select(bool condition, u32[8] left, u32[8] right) -> (u32[8], u32[8]) {\r\n    return (condition ? right : left, condition ? left : right);\r\n}\r\n\r\n// Merke-Tree inclusion proof for tree depth 3 using sha256\r\n// directionSelector => true if current digest is on the rhs of the hash\r\ndef main(u32[8] root, private u32[8] leaf, private bool[DEPTH] directionSelector, private u32[DEPTH][8] path) -> bool {\r\n    // Start from the leaf\r\n    u32[8] mut digest = leaf;\r\n\r\n\t// Loop up the tree\r\n    for u32 i in 0..DEPTH {\r\n\t    (u32[8], u32[8]) s = select(directionSelector[i], digest, path[i]);\r\n\t    digest = hash(s.0, s.1);\r\n    }\r\n\r\n    return digest == root;\r\n}","sha256":"import \"hashes/sha256/sha256Padded\";\r\n\r\ndef main(u8[4] input, u32[8] expected_hash) {\r\n    u32[8] hash = sha256Padded(input);\r\n    assert(hash == expected_hash);\r\n    return;\r\n}"}},"__N_SSG":true}